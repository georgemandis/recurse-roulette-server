<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Recurse Roulette</title>
  <script src="https://browser.sentry-cdn.com/5.15.2/bundle.min.js"
    integrity="sha384-HA4Glk4hAwUFBIu+OfNR4bvn6vGCxT134gRiQce9rwp2YfxcuHHG8nG7qkooJwFt" crossorigin="anonymous">
    </script>
  <script src="/js/peerjs.min.js"></script>
  <script src="/js/konami.js"></script>
  <link href="https://fonts.googleapis.com/css?family=Libre+Baskerville:400,400i" rel="stylesheet" />
  <link rel="stylesheet" type="text/css" href="style/main.css" />
</head>

<body>
  <nav>
    <a class="margin-x" href="/">
      <img class="logo" src="media/logo.svg" />
    </a>
    <div class="nav-container">
      <a class="nav-link margin-x" target="_blank"
        href="https://github.com/georgemandis/recurse-roulette-server">Github</a>
    </div>
  </nav>

  <div class="content flex-column vertical-center margin-y">
    <h1 class="title margin-y">Recurse Roulette</h1>
    <h3 class="title margin-bottom" id="onlinePeers">--</h3>
    <!-- Join and End Call buttons -->
    <div class="flex-row">
      <!--Join the queue-->
      <button class="button margin-bottom margin-x-small" id="connect">
        Join
      </button>
      <!--End the call-->
      <button class="button margin-bottom margin-x-small" id="close" disabled>
        Hang Up
      </button>
    </div>

    <!-- video streams -->
    <div class="flex-row">
      <!--Video stream for me-->
      <div class="flex-column">
        <div class="video-container margin-bottom">
          <video id="me" autoplay="autoplay" muted></video>
          <div id="myUserInfo" class="name-tag">
            <img class="mute-icon" id="myMuteIcon" src="media/mute.svg" />
            <span class="name"></span>
            <span class="pronouns"></span>
            <span class="timezone"></span>
          </div>
        </div>
        <div class="flex-row">
          <button class="button margin-bottom margin-x-small" disabled id="muteButton">
            Mute
          </button>
          <button class="button margin-bottom margin-x-small" disabled id="videoButton">
            Stop Video
          </button>
        </div>
      </div>
      <!--Video stream for connect peer-->
      <div class="flex-column">
        <div class="video-container margin-bottom">
          <video id="you" autoplay="autoplay"></video>
          <div id="peerUserInfo" class="name-tag">
            <img class="mute-icon" id="peerMuteIcon" src="media/mute.svg" />
            <span class="name"></span>
            <span class="pronouns"></span>
            <span class="timezone"></span>
          </div>
        </div>
      </div>
    </div>

    <marquee class="margin-y">
      <strong>Social Rules</strong>: 1. No well-actuallyâ€™s &nbsp;&nbsp; 2. No
      feigning surprise &nbsp;&nbsp; 3. No backseat driving &nbsp;&nbsp; 4. No
      subtle -isms
    </marquee>
  </div>

  <script>
    Sentry.init({ dsn: 'https://aa873a0abe8b4ad8bb2a6f32c5fa2ffb@sentry.io/5177870' });

    // checks if this is a dev environment
    const isDev = location.hostname === 'localhost';
    // video elements for the two streams
    const me = document.querySelector("#me");
    const you = document.querySelector("#you");
    let myPeerID, yourPeerID, stream, peer, waitForPeer, peerCall, peerConn;

    // the state keeps track of the current user's mic and name-tag
    let state = {
      isMuted: false
    };

    // query selectors used throughout code
    const peerMuteIcon = document.querySelector("#peerMuteIcon");
    const myMuteIcon = document.querySelector("#myMuteIcon");
    const onlinePeersSpan = document.querySelector("#onlinePeers");

    // peer name-tag query selectors
    const peerNameTag = document.querySelector("#peerUserInfo")
    const peerName = document.querySelector("#peerUserInfo .name")
    const peerPronouns = document.querySelector("#peerUserInfo .pronouns")
    const peerTimezone = document.querySelector("#peerUserInfo .timezone")

    // my name-tag query selectors
    const myNameTag = document.querySelector("#myUserInfo")
    const myName = document.querySelector("#myUserInfo .name")
    const myPronouns = document.querySelector("#myUserInfo .pronouns")
    const myTimezone = document.querySelector("#myUserInfo .timezone")

    // buttons query selectors
    const muteButton = document.querySelector("#muteButton");
    const videoButton = document.querySelector("#videoButton");
    const connectButton = document.querySelector("#connect");
    const hangupButton = document.querySelector("#close");

    // updates how many peers are online every second
    const checkForOnlinePeers = setInterval(async () => {
      const currentOnlinePeers = await (await fetch("/api/online")).json();
      onlinePeersSpan.textContent = `${currentOnlinePeers} Recurser${
        currentOnlinePeers === 1 ? "" : "s"
        } Online`;
    }, 1000);

    // mute and audio buttons
    muteButton.addEventListener("click", () => {
      modifyStream("audio", event.target);
    });
    videoButton.addEventListener("click", () =>
      modifyStream("video", event.target)
    );

    // join and hangup buttons
    connectButton.addEventListener("click", makeConnection);
    hangupButton.addEventListener("click", () => {
      if (isConnected() == false) {
        // if the roulette has started, end it and destroy the peer
        clearInterval(waitForPeer);
        peer.destroy();
        // remove loading animation, enable join button, disable hangup button
        you.classList.remove("loading");
        connectButton.removeAttribute("disabled");
        hangupButton.disabled = true;
        return false;
      }

      // if you are connected hang up
      console.log("Clicked hangup");
      handleClose();

    });

    // fetches an available peer from the API endpoint
    async function startRoulette() {
      // fetches all of the available peers
      const getPeers = await fetch("/api/peers");
      const availablePeers = new Set(await getPeers.json());
      // removes the current peer ID so you can't pair with yourself
      availablePeers.delete(myPeerID);
      const firstAvailablePeer = availablePeers.values().next().value;

      //initiates a call and connection
      peerCall = peer.call(firstAvailablePeer, stream);
      peerConn = peer.connect(firstAvailablePeer);

      peerCall.on("stream", handleStream);
      peerCall.on("close", handleClose);
      peerCall.on("error", errHandler("peerCall"));

      // sends the current state to tell the peer if the stream is muted
      peerConn.on("open", () => peerConn.open && peerConn.send(state));
      peerConn.on("data", handleConnection);
      peerConn.on("error", errHandler("peerConn"));
    }

    function errHandler(prefix) {
      return err => {
        console.log(`${prefix} <${err.type}>: ${err}`);
        throw new Error(err);
      }
    }

    async function makeConnection() {
      //disable join button, enable hang up mute and stop video buttons
      connectButton.disabled = true;
      hangupButton.removeAttribute("disabled");
      muteButton.removeAttribute("disabled");
      videoButton.removeAttribute("disabled");
      // add loading animation
      you.classList.add("loading");

      // user info from the API
      const endpoint = isDev ? "test-user.json" : "/api/me";
      console.log(isDev ? "IS dev" : "is NOT dev");
      state.userInfo =
        state.userInfo || (await (await fetch(endpoint,
          {
            headers: new Headers({
              'content-type': 'application/json',
              'charset': 'utf-8'
            }),
          }
        )).json());

      // figure out timezone
      const offset = (new Date().getTimezoneOffset() * -1) / 60;
      const hrs = Math.floor(offset);
      const min = offset - hrs;
      const offsetString = `${Math.floor((hrs + min) * 100)}`;
      state.userInfo.timezone = `GMT ${
        offset >= 0 ? "+" : ""
        }${offsetString}`;

      // fill in your own user information
      myNameTag.classList.add("flex-row")
      myName.textContent = `${state.userInfo.name}`;
      myPronouns.textContent = `(${state.userInfo.pronouns})`;
      myTimezone.textContent = `${state.userInfo.timezone}`;

      // initiate media stream
      if (!me.srcObject) {
        stream = await navigator.mediaDevices.getUserMedia({
          video: true,
          audio: true
        });
        console.log(stream);

        // put the stream to the HTML video object
        me.srcObject = stream;
        me.play();
      }

      if (
        peer === undefined ||
        (typeof peer === "object" && peer.destroyed)
      ) {
        setupPeer();
        console.log("I have set up a peer", peer);
      }
    }

    function setupPeer() {
      //change this value if you deploy your own instance of recurse roulette
      peer = new Peer({
        host: isDev ? location.hostname : "recurse-roulette.herokuapp.com",
        port: location.port,
        path: "/peer"
      });

      // connect to the signaling server
      peer.on("open", function (id) {
        myPeerID = id;
        console.log("Opening conection to PeerJS", id);
        waitForPeer = setInterval(startRoulette, 1000);
      });

      // make connection to peer
      peer.on("connection", function (conn) {
        if (isConnected()) {
          console.log("data connection made, but already have connection. REJECTED.");
          // reject this incoming conection
          conn.close();
          return false;
        }
        peerConn = conn;
        // sends the current state to tell the peer if the stream is muted
        peerConn.on("open", () => peerConn.send(state));
        peerConn.on("data", handleConnection);
      });

      // fires when another peer calls the current user
      peer.on("call", async function (call) {
        // if the current user is already connected to a call, reject this call
        if (isConnected()) {
          console.log("call received, but already on call. REJECTED.");
          // reject this incoming call
          call.close();
          return false;
        }

        console.log("Receiving call");

        // sets the global peerCall object to the call
        peerCall = call;
        // answer the call and send the the current user's stream
        peerCall.answer(stream);
        peerCall.on("stream", handleStream);
        peerCall.on("close", handleClose);
      });
    }

    async function handleStream(remoteStream) {
      // remove loading animation
      you.classList.remove("loading");

      // sets the source for the video element to the incoming stream
      you.srcObject = remoteStream;
      // removes the current user's peer id from the list
      await fetch(`/api/peers/consume/${myPeerID}`);
      // ends the roulette
      clearInterval(waitForPeer);
    }

    function handleClose() {
      // tell the remote peer that we're hanging up
      if (isConnected()) {
        peerConn && peerConn.open && peerConn.send({ hangup: 'l8rz' });
      }
      // remote stream to the video element
      you.srcObject = null;

      // close the connection and DESTRUCTION to the peer
      // (abandon all hope, ye who enter peer)
      peerCall.close();
      peerConn.close();
      peer.destroy();

      // hide peer name tag
      peerNameTag.classList.remove("flex-row")
      // remove muted icon for peer
      peerMuteIcon.style.display = "none";
      // remove peer user info
      peerName.textContent = "";
      peerPronouns.textContent = "";
      peerTimezone.textContent = "";

      // disable hangup button, enable connect button
      hangupButton.disabled = true;
      connectButton.removeAttribute("disabled");
      console.log("Connection closed");
    }

    function handleConnection(data) {
      console.log("data in handleConnection: ", data);

      // fill in the user name-tag information
      peerNameTag.classList.add("flex-row")
      peerName.textContent = `${data.userInfo.name}`;
      peerPronouns.textContent = `(${data.userInfo.pronouns})`;
      peerTimezone.textContent = `${data.userInfo.timezone}`;

      // sends information about if the peer is muted
      if (data.isMuted) {
        peerMuteIcon.style.display = "block";
      } else {
        peerMuteIcon.style.display = "none";
      }
      // the peer sends a hangup event when they initiate a hang up
      if (data.hangup) {
        console.log("Got a hangup");
        handleClose()
      }
    }

    // event handler for the mute and video buttons
    // streamName can be "video" or "audio"
    function modifyStream(streamName, target) {
      if (!stream) {
        return false;
      }
      // finds if the specified stream is enabled
      let isEnabled = stream
        .getTracks()
        .filter(stream => stream.kind === streamName)[0].enabled;

      // flips the value of isEnabled
      let isCurrentlyEnabled = !isEnabled;

      // toggles the stream by directly modifying the stream object
      stream
        .getTracks()
        .filter(
          stream => stream.kind === streamName
        )[0].enabled = isCurrentlyEnabled;

      // edits the HTML of the target
      if (streamName === "audio") {
        target.textContent = `${isCurrentlyEnabled ? "Mute" : "Unmute"}`
        myMuteIcon.style.display = `${isCurrentlyEnabled ? "none" : "inline"}`
        // if the audio stream is enabled, the user is not muted. So flip the value of isCurrentlyEnabled.
        let isMuted = !isCurrentlyEnabled;
        // update the state and send it to the peer
        state.isMuted = isMuted;

        if (isConnected()) {
          peerConn.send(state);
        }
      } else if (streamName === "video") {
        target.textContent = `${isCurrentlyEnabled ? "Stop" : "Start"} Video`;
      }
    }
    // determine if the peer stream connected
    function isConnected() {
      return (peerConn && peerConn.open && peerCall && peerCall.open && you.srcObject) ? true : false;
    }

    // bill
    (() => {
      const bill = new Konami(() => {
        const bills = [
          "billandbees.jpg",
          "billandirshmen.jpg",
          "billspace.jpg"
        ];
        you.poster = `/media/${
          bills[Math.floor(Math.random() * bills.length)]
          }`;
        clearInterval(checkForOnlinePeers);
        onlinePeersSpan.textContent = "Bill is Online";
        const marquee = document.querySelector("marquee");
        marquee.innerHTML =
          "<marquee scrollamount='20' behavior='alternate' style='width:30%;color:#00A0E6'>Gotta go fast!</marquee>";
      });
    })();
  </script>
</body>

</html>